<#
.SYNOPSIS
    Parses a PowerShell event log file into structured objects.
.DESCRIPTION
    This function reads a tab-separated log file with multi-line messages,
    like the one generated by PowerShell event logging, and converts each
    log entry into a PSCustomObject.
.PARAMETER Path
    The full path to the log file to be parsed.
.EXAMPLE
    PS C:\> Parse-SobytiyaLog -Path "C:\Users\joker\OneDrive\Dokumenti\события.txt"
    
    This will parse the specified log file and output an array of objects,
    one for each log entry.
.OUTPUTS
    [PSCustomObject[]] An array of objects representing the parsed log entries.
    Returns $null if no entries are found or the file is empty.
#>
function Parse-SobytiyaLog {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [string]$Path
    )

    if (-not (Test-Path -Path $Path -PathType Leaf)) {
        throw "File not found or is a directory: $Path"
    }

    # Read all lines, skipping the header line.
    $lines = Get-Content -Path $Path -Encoding UTF8 | Select-Object -Skip 1

    if (-not $lines) {
        return $null
    }

    $records = [System.Collections.Generic.List[string[]]]::new()
    $currentRecord = [System.Collections.Generic.List[string]]::new()

    foreach ($line in $lines) {
        # A new record starts with a non-indented line.
        if ($line -notmatch '^\s' -and $currentRecord.Count -gt 0) {
            $records.Add([string[]]$currentRecord)
            $currentRecord.Clear()
        }
        $currentRecord.Add($line)
    }

    # Add the last record
    if ($currentRecord.Count -gt 0) {
        $records.Add([string[]]$currentRecord)
    }

    $parsedEvents = foreach ($recordLines in $records) {
        $firstLine = $recordLines[0]
        
        # Regex to parse the tab-separated header and the beginning of the message
        $match = [regex]::Match($firstLine, '^(?<Level>[^\t]+)\t(?<DateTime>[^\t]+)\t(?<Source>[^\t]+)\t(?<EventID>\d+)\t(?<TaskCategory>[^\t]+)\t"(?<MessageStart>.*)')
        
        if ($match.Success) {
            $message = ($match.Groups['MessageStart'].Value + "`n" + ($recordLines[1..($recordLines.Count-1)] -join "`n")).Trim().Trim('"')
            
            $details = @{}
            $message -split '\r?\n' | Where-Object { $_ -match '^\s*(?<Key>[^=]+?)\s*=\s*(?<Value>.*)' } | ForEach-Object {
                $details[$matches.Key.Trim()] = $matches.Value.Trim()
            }

            [PSCustomObject]@{
                Level        = $match.Groups['Level'].Value.Trim()
                Timestamp    = [datetime]::ParseExact($match.Groups['DateTime'].Value.Trim(), 'dd.MM.yyyy H:mm:ss', $null)
                Source       = $match.Groups['Source'].Value.Trim()
                EventID      = [int]$match.Groups['EventID'].Value
                TaskCategory = $match.Groups['TaskCategory'].Value.Trim()
                Message      = $message
                Details      = [pscustomobject]$details
            }
        }
    }
    return $parsedEvents
}